<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Modality Agreement</title>

<style>
  body { margin: 0; overflow: hidden; background: #111; color: #eee; }
  #ui {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    font-family: sans-serif;
  }
  #timeLabel {
    text-align: center;
    margin-bottom: 6px;
    font-size: 14px;
  }
</style>
</head>

<body>

<div id="ui">
  <div id="timeLabel">t = 0.00</div>
  <input id="timeSlider" type="range" min="0" max="1" step="0.001">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ============================================================
   Scene / Camera / Renderer
============================================================ */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  70, window.innerWidth / window.innerHeight, 0.1, 100
);
camera.position.set(0, 0, 7);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ============================================================
   Globals
============================================================ */

const group = new THREE.Group();
scene.add(group);

const nodes = {};
const edges = {};
const originalPositions = {};

let rows = [], timeValues = [], pairKeys = [], modalities = [];
let focused = null;

// layout + interaction
const SPHERE_RADIUS = 2.6;
const FOCUS_DEPTH = 3.0;
const ANIM_SPEED = 0.08;

const targetQuat = new THREE.Quaternion();
const targetPos  = new THREE.Vector3();
const IDENTITY_QUAT = new THREE.Quaternion();

/* ============================================================
   Load CSV (with fallback)
============================================================ */

fetch("modality_agreement_timeseries.csv")
  .then(r => {
    if (!r.ok) throw new Error("CSV not found");
    return r.text();
  })
  .then(text => parseCSV(text))
  .catch(() => generateDummyData())
  .finally(() => init());

function parseCSV(text) {
  const lines = text.trim().split("\n");
  const headers = lines[0].split(",");
  rows = lines.slice(1).map(l => {
    const p = l.split(",");
    const o = {};
    headers.forEach((h, i) => o[h] = parseFloat(p[i]));
    return o;
  });
  timeValues = rows.map(r => r.time);
  pairKeys = headers.filter(h => h !== "time");
  modalities = [...new Set(pairKeys.flatMap(k => k.split("__")))];
}

function generateDummyData() {
  modalities = ["AUDIO", "MPIPE", "IMU", "VIDEO"];
  timeValues = [0];
  pairKeys = [];
}

/* ============================================================
   Init
============================================================ */

function init() {

  /* ---------- Nodes (spherical layout) ---------- */
  modalities.forEach((name, i) => {
    const n = modalities.length;
    const phi = Math.acos(1 - 2 * (i + 0.5) / n);
    const theta = Math.PI * (1 + Math.sqrt(5)) * i;

    const pos = new THREE.Vector3(
      SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta),
      SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta),
      SPHERE_RADIUS * Math.cos(phi)
    );

    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.22, 20, 20),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );

    mesh.position.copy(pos);
    group.add(mesh);

    nodes[name] = mesh;
    originalPositions[name] = pos.clone();
  });

  /* ---------- Edges ---------- */
  pairKeys.forEach(k => {
    const [a, b] = k.split("__");
    const geom = new THREE.BufferGeometry().setFromPoints([
      nodes[a].position,
      nodes[b].position
    ]);
    const mat = new THREE.LineBasicMaterial({
      color: 0x66ccff,
      transparent: true,
      opacity: 0.15
    });
    const line = new THREE.Line(geom, mat);
    group.add(line);
    edges[k] = line;
  });

  targetQuat.copy(IDENTITY_QUAT);
  targetPos.set(0, 0, 0);

  setupPicking();
  setupUI();
  updateEdges(timeValues[0] || 0);
  animate();
}

/* ============================================================
   Picking & Focus
============================================================ */

function setupPicking() {
  const ray = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  window.addEventListener("click", e => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(Object.values(nodes));
    if (!hits.length) return;

    const clicked = Object.keys(nodes)
      .find(k => nodes[k] === hits[0].object);

    toggleFocus(clicked);
  });
}

function toggleFocus(name) {
  if (focused === name) {
    targetQuat.copy(IDENTITY_QUAT);
    targetPos.set(0, 0, 0);
    focused = null;
  } else {
    const dir = originalPositions[name].clone();
    if (dir.length() < 1e-6) return;
    dir.normalize();

    targetQuat.copy(
      new THREE.Quaternion().setFromUnitVectors(dir, new THREE.Vector3(0, 0, 1))
    );
    targetPos.set(0, 0, -FOCUS_DEPTH);
    focused = name;
  }
}

/* ============================================================
   Time / Edge updates
============================================================ */

function updateEdges(t) {
  let idx = 0, best = Infinity;
  for (let i = 0; i < timeValues.length; i++) {
    const d = Math.abs(timeValues[i] - t);
    if (d < best) { best = d; idx = i; }
  }

  document.getElementById("timeLabel").textContent =
    `t = ${timeValues[idx]?.toFixed(2) ?? "0.00"}`;

  pairKeys.forEach(k => {
    const v = rows[idx]?.[k];
    const e = edges[k];
    if (!isFinite(v)) { e.visible = false; return; }
    e.visible = true;
    e.material.opacity = 0.1 + 0.8 * v;
  });
}

/* ============================================================
   UI
============================================================ */

function setupUI() {
  const s = document.getElementById("timeSlider");
  if (!timeValues.length) return;
  s.min = timeValues[0];
  s.max = timeValues[timeValues.length - 1];
  s.step = (s.max - s.min) / 1000;
  s.addEventListener("input", () => updateEdges(parseFloat(s.value)));
}

/* ============================================================
   Render loop
============================================================ */

function animate() {
  requestAnimationFrame(animate);

  // gentle idle rotation (optional)
  if (!focused) group.rotation.y += 0.002;

  group.quaternion.slerp(targetQuat, ANIM_SPEED);
  group.position.lerp(targetPos, ANIM_SPEED);

  renderer.render(scene, camera);
}
</script>

</body>
</html>
