<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Modality Agreement (DEBUG SAFE)</title>

<style>
  body { margin: 0; overflow: hidden; background: #111; color: #eee; }
  #ui {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
  }
  #timeLabel { text-align: center; margin-bottom: 6px; }
</style>
</head>

<body>

<div id="ui">
  <div id="timeLabel">t = 0.00</div>
  <input id="timeSlider" type="range" min="0" max="1" step="0.001">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ============================================================
   Scene / Camera / Renderer
============================================================ */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 7);
camera.lookAt(0, 0, 0);   // ⭐ CRITICAL FIX

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ============================================================
   DEBUG HELPERS (TEMPORARY BUT IMPORTANT)
============================================================ */

// Axis helper so we ALWAYS see something
scene.add(new THREE.AxesHelper(3));

/* ============================================================
   Globals
============================================================ */

const group = new THREE.Group();
scene.add(group);

const nodes = {};
const originalPositions = {};

const SPHERE_RADIUS = 2.5;

/* ============================================================
   SAFE DATA LOADING
============================================================ */

let rows = [];
let timeValues = [];
let pairKeys = [];
let modalities = [];

fetch("modality_agreement_timeseries.csv")
  .then(r => {
    if (!r.ok) throw new Error("CSV not found");
    return r.text();
  })
  .then(text => {
    console.log("[CSV] Loaded successfully");
    parseCSV(text);
    init();
  })
  .catch(err => {
    console.warn("[CSV] Failed to load, using dummy data", err);
    generateDummyData();
    init();
  });

function parseCSV(text) {
  const lines = text.trim().split("\n");
  const headers = lines[0].split(",");
  rows = lines.slice(1).map(l => {
    const p = l.split(",");
    const o = {};
    headers.forEach((h, i) => o[h] = parseFloat(p[i]));
    return o;
  });
  timeValues = rows.map(r => r.time);
  pairKeys = headers.filter(h => h !== "time");
  modalities = [...new Set(pairKeys.flatMap(k => k.split("__")))];
}

function generateDummyData() {
  modalities = ["AUDIO", "MPIPE", "IMU", "VIDEO"];
  timeValues = [0];
}

/* ============================================================
   Init (NODES ONLY — KEEP SIMPLE)
============================================================ */

function init() {
  console.log("[INIT] Creating nodes:", modalities);

  modalities.forEach((name, i) => {
    const n = modalities.length;
    const phi = Math.acos(1 - 2 * (i + 0.5) / n);
    const theta = Math.PI * (1 + Math.sqrt(5)) * i;

    const pos = new THREE.Vector3(
      SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta),
      SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta),
      SPHERE_RADIUS * Math.cos(phi)
    );

    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.3, 24, 24),
      new THREE.MeshBasicMaterial({ color: 0xffcc00 }) // BRIGHT YELLOW
    );

    mesh.position.copy(pos);
    group.add(mesh);

    nodes[name] = mesh;
    originalPositions[name] = pos.clone();
  });

  animate();
}

/* ============================================================
   Render loop
============================================================ */

function animate() {
  requestAnimationFrame(animate);
  group.rotation.y += 0.002; // slow rotation so you SEE depth
  renderer.render(scene, camera);
}
</script>

</body>
</html>
