<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Modality Agreement</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    color: #eee;
    font-family: sans-serif;
  }
  #ui {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 12px;
  }
  button {
    background: #222;
    color: #eee;
    border: 1px solid #555;
    padding: 4px 10px;
    cursor: pointer;
  }
  button:hover {
    background: #333;
  }
  #timeLabel {
    text-align: center;
    font-size: 14px;
  }
</style>
</head>

<body>

<div id="ui">
  <div id="timeLabel">t = 0.00 sec</div>
  <input id="timeSlider" type="range" min="0" max="1" step="0.001">
  <div id="controls">
    <button id="playBtn">▶ Play</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ============================================================
   Scene / Camera / Renderer
============================================================ */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  70, window.innerWidth / window.innerHeight, 0.1, 100
);
camera.position.set(0, 0, 7);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ============================================================
   Globals
============================================================ */

const group = new THREE.Group();
scene.add(group);

const nodes = {};
const labels = {};
const edges = {};
const originalPositions = {};

let rows = [], timeValues = [], pairKeys = [], modalities = [];
let focused = null;

// layout
const SPHERE_RADIUS = 2.6;
const FOCUS_DEPTH = 3.0;

// node geometry
const NODE_RADIUS = 0.22;

// edge thickness
const EDGE_MIN = 0.015;
const EDGE_MAX = 0.10;

// animation
const ANIM_SPEED = 0.08;
const targetQuat = new THREE.Quaternion();
const targetPos  = new THREE.Vector3();
const IDENTITY_QUAT = new THREE.Quaternion();

// time playback
let currentTime = 0;
let isPlaying = false;
let direction = 1;
const playSpeed = 1.0;   // real seconds / second

/* ============================================================
   Modality label helper (YOUR RULE)
============================================================ */

function modalityDisplayName(fullName) {
  const idx = fullName.lastIndexOf("_");
  if (idx === -1) return fullName;
  return fullName.slice(idx + 1);
}

/* ============================================================
   Label helper
============================================================ */

function makeLabel(text) {
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const size = 256;
  canvas.width = size;
  canvas.height = size;

  ctx.clearRect(0, 0, size, size);
  ctx.font = "48px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "#ffffff";
  ctx.fillText(text, size / 2, size / 2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;

  const material = new THREE.SpriteMaterial({
    map: texture,
    transparent: true
  });

  const sprite = new THREE.Sprite(material);
  sprite.scale.set(1.2, 1.2, 1.2);
  return sprite;
}

/* ============================================================
   Load CSV
============================================================ */

fetch("modality_agreement_timeseries.csv")
  .then(r => r.ok ? r.text() : Promise.reject())
  .then(parseCSV)
  .catch(generateDummyData)
  .finally(init);

function parseCSV(text) {
  const lines = text.trim().split("\n");
  const headers = lines[0].split(",");
  rows = lines.slice(1).map(l => {
    const p = l.split(",");
    const o = {};
    headers.forEach((h, i) => o[h] = parseFloat(p[i]));
    return o;
  });
  timeValues = rows.map(r => r.time);
  pairKeys = headers.filter(h => h !== "time");
  modalities = [...new Set(pairKeys.flatMap(k => k.split("__")))];
  currentTime = timeValues[0];
}

function generateDummyData() {
  modalities = ["exp5b_pdps_imu-Clip", "exp5b_mpipe-R"];
  timeValues = [0, 100];
  pairKeys = [];
  currentTime = 0;
}

/* ============================================================
   Init
============================================================ */

function init() {

  modalities.forEach((name, i) => {
    const n = modalities.length;
    const phi = Math.acos(1 - 2 * (i + 0.5) / n);
    const theta = Math.PI * (1 + Math.sqrt(5)) * i;

    const pos = new THREE.Vector3(
      SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta),
      SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta),
      SPHERE_RADIUS * Math.cos(phi)
    );

    const node = new THREE.Mesh(
      new THREE.SphereGeometry(NODE_RADIUS, 24, 24),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );

    node.position.copy(pos);
    group.add(node);
    nodes[name] = node;
    originalPositions[name] = pos.clone();

    // <<< LABEL FIX HERE >>>
    const labelText = modalityDisplayName(name);
    const label = makeLabel(labelText);
    label.position.copy(pos).add(new THREE.Vector3(0, NODE_RADIUS + 0.35, 0));
    group.add(label);
    labels[name] = label;
  });

  pairKeys.forEach(k => {
    const mat = new THREE.MeshBasicMaterial({
      color: 0x66ccff,
      transparent: true,
      opacity: 0.15
    });
    const geom = new THREE.CylinderGeometry(1, 1, 1, 12);
    const mesh = new THREE.Mesh(geom, mat);
    group.add(mesh);
    edges[k] = mesh;
  });

  targetQuat.copy(IDENTITY_QUAT);
  targetPos.set(0, 0, 0);

  setupPicking();
  setupUI();
  updateEdges(currentTime);
  animate();
}

/* ============================================================
   Picking & Focus
============================================================ */

function setupPicking() {
  const ray = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  window.addEventListener("click", e => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(Object.values(nodes));
    if (!hits.length) return;

    const clicked = Object.keys(nodes)
      .find(k => nodes[k] === hits[0].object);

    toggleFocus(clicked);
  });
}

function toggleFocus(name) {
  if (focused === name) {
    targetQuat.copy(IDENTITY_QUAT);
    targetPos.set(0, 0, 0);
    focused = null;
  } else {
    const dir = originalPositions[name].clone().normalize();
    targetQuat.copy(
      new THREE.Quaternion().setFromUnitVectors(dir, new THREE.Vector3(0, 0, 1))
    );
    targetPos.set(0, 0, -FOCUS_DEPTH);
    focused = name;
  }
}

/* ============================================================
   Edge geometry update
============================================================ */

function updateEdgeCylinder(edge, p1, p2, thickness) {
  const dir = new THREE.Vector3().subVectors(p2, p1);
  const fullLen = dir.length();
  if (fullLen <= 2 * NODE_RADIUS) {
    edge.visible = false;
    return;
  }

  const usableLen = fullLen - 2 * NODE_RADIUS;
  dir.normalize();

  const mid = new THREE.Vector3()
    .copy(p1)
    .addScaledVector(dir, NODE_RADIUS + usableLen / 2);

  edge.position.copy(mid);
  edge.scale.set(thickness, usableLen, thickness);
  edge.quaternion.setFromUnitVectors(
    new THREE.Vector3(0, 1, 0),
    dir
  );
}

/* ============================================================
   Time / Edge updates
============================================================ */

function updateEdges(t) {
  let idx = 0, best = Infinity;
  for (let i = 0; i < timeValues.length; i++) {
    const d = Math.abs(timeValues[i] - t);
    if (d < best) { best = d; idx = i; }
  }

  document.getElementById("timeLabel").textContent =
    `t = ${(timeValues[idx] / 10).toFixed(2)} sec`;

  pairKeys.forEach(k => {
    const v = rows[idx]?.[k];
    const edge = edges[k];
    if (!isFinite(v)) { edge.visible = false; return; }

    edge.visible = true;
    const [a, b] = k.split("__");
    const thickness =
      EDGE_MIN + Math.pow(v, 1.3) * (EDGE_MAX - EDGE_MIN);

    updateEdgeCylinder(edge, nodes[a].position, nodes[b].position, thickness);
    edge.material.opacity = 0.15 + 0.85 * v;
  });
}

/* ============================================================
   UI
============================================================ */

function setupUI() {
  const slider = document.getElementById("timeSlider");
  const playBtn = document.getElementById("playBtn");

  slider.min = timeValues[0];
  slider.max = timeValues[timeValues.length - 1];
  slider.step = (slider.max - slider.min) / 1000;
  slider.value = currentTime;

  slider.addEventListener("input", () => {
    currentTime = parseFloat(slider.value);
    isPlaying = false;
    playBtn.textContent = "▶ Play";
    updateEdges(currentTime);
  });

  playBtn.addEventListener("click", () => {
    isPlaying = !isPlaying;
    playBtn.textContent = isPlaying ? "⏸ Pause" : "▶ Play";
  });
}

/* ============================================================
   Render loop
============================================================ */

let lastFrame = performance.now();

function animate(now = performance.now()) {
  requestAnimationFrame(animate);

  const dt = (now - lastFrame) / 1000;
  lastFrame = now;

  if (isPlaying && timeValues.length > 1) {
    currentTime += direction * playSpeed * dt * 10;

    if (currentTime >= timeValues[timeValues.length - 1]) {
      currentTime = timeValues[timeValues.length - 1];
      direction = -1;
    } else if (currentTime <= timeValues[0]) {
      currentTime = timeValues[0];
      direction = 1;
    }

    document.getElementById("timeSlider").value = currentTime;
    updateEdges(currentTime);
  }

  if (!focused) group.rotation.y += 0.002;

  group.quaternion.slerp(targetQuat, ANIM_SPEED);
  group.position.lerp(targetPos, ANIM_SPEED);

  // label depth scaling
  Object.values(labels).forEach(label => {
    const d = camera.position.distanceTo(label.position);
    const s = THREE.MathUtils.clamp(6 / d, 0.6, 1.4);
    label.scale.set(s, s, s);
  });

  renderer.render(scene, camera);
}
</script>

</body>
</html>
