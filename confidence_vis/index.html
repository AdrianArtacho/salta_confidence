<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Modality Agreement</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    color: #eee;
    font-family: sans-serif;
  }
  #ui {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  #controls {
    display: flex;
    justify-content: center;
    gap: 12px;
  }
  button {
    background: #222;
    color: #eee;
    border: 1px solid #555;
    padding: 4px 10px;
    cursor: pointer;
  }
  button:hover {
    background: #333;
  }
  #timeLabel {
    text-align: center;
    font-size: 14px;
  }
</style>
</head>

<body>

<div id="ui">
  <div id="timeLabel">t = 0.00 sec</div>
  <input id="timeSlider" type="range">
  <div id="controls">
    <button id="playBtn">⏸ Pause</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ============================================================
   Scene / Camera / Renderer
============================================================ */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 100);
camera.position.set(0, 0, 7);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ============================================================
   Globals
============================================================ */

const group = new THREE.Group();
scene.add(group);

const nodes = {};
const labels = {};
const edges = {};
const originalPositions = {};

let rows = [], timeValues = [], pairKeys = [], modalities = [];

const SPHERE_RADIUS = 2.6;
const NODE_RADIUS   = 0.22;
const EDGE_MIN = 0.015;
const EDGE_MAX = 0.10;
const ANIM_SPEED = 0.08;
const FOCUS_DEPTH = 3.0;

let currentTime = 0;
let isPlaying = true;   // ▶ AUTOPLAY ON LOAD
let direction = 1;
const playSpeed = 1.0;

/* ============================================================
   Helpers
============================================================ */

function modalityDisplayName(full) {
  const i = full.lastIndexOf("_");
  return i === -1 ? full : full.slice(i + 1);
}

function modalityColor(label) {
  label = label.toLowerCase();
  if (label.includes("mpipe")) return new THREE.Color(0xffc0c0); // soft red
  if (label.includes("audio")) return new THREE.Color(0x9fb7ff); // clearer blue
  if (label.includes("imu"))   return new THREE.Color(0xc8f0c8); // soft green
  return new THREE.Color(0xffffff);
}

/* ============================================================
   Label helper
============================================================ */

function makeLabel(text) {
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d");
  c.width = c.height = 256;
  ctx.font = "48px sans-serif";
  ctx.fillStyle = "#fff";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 128, 128);
  const tex = new THREE.CanvasTexture(c);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
  const s = new THREE.Sprite(mat);
  s.scale.set(1.2, 1.2, 1.2);
  return s;
}

/* ============================================================
   CSV
============================================================ */

fetch("modality_agreement_timeseries.csv")
  .then(r => r.text())
  .then(parseCSV)
  .catch(() => {
    modalities = ["exp5b_pdps_imu-Clip","exp5b_mpipe-R","exp5b_audio-L"];
    timeValues = [0,100];
    pairKeys = [];
  })
  .finally(init);

function parseCSV(t) {
  const lines = t.trim().split("\n");
  const h = lines[0].split(",");
  rows = lines.slice(1).map(l => {
    const p = l.split(",");
    const o = {};
    h.forEach((k,i)=>o[k]=parseFloat(p[i]));
    return o;
  });
  timeValues = rows.map(r=>r.time);
  pairKeys = h.filter(k=>k!=="time");
  modalities = [...new Set(pairKeys.flatMap(k=>k.split("__")))];
  currentTime = timeValues[0];
}

/* ============================================================
   Init
============================================================ */

function init() {

  modalities.forEach((name,i)=>{
    const phi = Math.acos(1 - 2*(i+0.5)/modalities.length);
    const theta = Math.PI*(1+Math.sqrt(5))*i;
    const pos = new THREE.Vector3(
      SPHERE_RADIUS*Math.sin(phi)*Math.cos(theta),
      SPHERE_RADIUS*Math.sin(phi)*Math.sin(theta),
      SPHERE_RADIUS*Math.cos(phi)
    );

    const labelText = modalityDisplayName(name);
    const color = modalityColor(labelText);

    const node = new THREE.Mesh(
      new THREE.SphereGeometry(NODE_RADIUS,24,24),
      new THREE.MeshBasicMaterial({ color })
    );
    node.position.copy(pos);
    group.add(node);
    nodes[name]=node;
    originalPositions[name]=pos.clone();

    const lbl = makeLabel(labelText);
    lbl.position.copy(pos).add(new THREE.Vector3(0,NODE_RADIUS+0.35,0));
    group.add(lbl);
    labels[name]=lbl;
  });

  pairKeys.forEach(k=>{
    const geom = new THREE.CylinderGeometry(1,1,1,16,1,true);
    geom.setAttribute(
      "color",
      new THREE.BufferAttribute(
        new Float32Array(geom.attributes.position.count*3),3
      )
    );
    const mat = new THREE.MeshBasicMaterial({
      vertexColors:true,
      transparent:true,
      opacity:0.2
    });
    const m = new THREE.Mesh(geom,mat);
    group.add(m);
    edges[k]=m;
  });

  setupUI();
  updateEdges(currentTime);
  animate();
}

/* ============================================================
   Gradient edge update
============================================================ */

function updateEdgeCylinder(edge,p1,p2,c1,c2,thickness){
  const dir = new THREE.Vector3().subVectors(p2,p1);
  const len = dir.length();
  if(len<=2*NODE_RADIUS){ edge.visible=false; return;}
  dir.normalize();
  const usable = len-2*NODE_RADIUS;
  edge.position.copy(p1).addScaledVector(dir,NODE_RADIUS+usable/2);
  edge.scale.set(thickness,usable,thickness);
  edge.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),dir);

  const colors = edge.geometry.attributes.color.array;
  const pos = edge.geometry.attributes.position.array;
  for(let i=0;i<pos.length;i+=3){
    const t = pos[i+1]+0.5;
    const col = c1.clone().lerp(c2,t);
    colors[i]=col.r; colors[i+1]=col.g; colors[i+2]=col.b;
  }
  edge.geometry.attributes.color.needsUpdate=true;
}

/* ============================================================
   Time update
============================================================ */

function updateEdges(t){
  let idx=0,best=1e9;
  for(let i=0;i<timeValues.length;i++){
    const d=Math.abs(timeValues[i]-t);
    if(d<best){best=d;idx=i;}
  }
  document.getElementById("timeLabel").textContent =
    `t = ${(timeValues[idx]/10).toFixed(2)} sec`;

  pairKeys.forEach(k=>{
    const v=rows[idx]?.[k];
    const e=edges[k];
    if(!isFinite(v)){e.visible=false;return;}
    e.visible=true;
    const [a,b]=k.split("__");
    const thickness=EDGE_MIN+Math.pow(v,1.3)*(EDGE_MAX-EDGE_MIN);
    updateEdgeCylinder(
      e,
      nodes[a].position,
      nodes[b].position,
      nodes[a].material.color,
      nodes[b].material.color,
      thickness
    );
    e.material.opacity=0.15+0.85*v;
  });
}

/* ============================================================
   UI + Animation
============================================================ */

function setupUI(){
  const s=document.getElementById("timeSlider");
  const b=document.getElementById("playBtn");
  s.min=timeValues[0];
  s.max=timeValues.at(-1);
  s.step=(s.max-s.min)/1000;
  s.value=currentTime;
  s.oninput=()=>{
    currentTime=parseFloat(s.value);
    isPlaying=false;
    b.textContent="▶ Play";
    updateEdges(currentTime);
  };
  b.onclick=()=>{
    isPlaying=!isPlaying;
    b.textContent=isPlaying?"⏸ Pause":"▶ Play";
  };
}

let last=performance.now();
function animate(now=performance.now()){
  requestAnimationFrame(animate);
  const dt=(now-last)/1000; last=now;

  if(isPlaying){
    currentTime+=direction*playSpeed*dt*10;
    if(currentTime>=timeValues.at(-1)){currentTime=timeValues.at(-1);direction=-1;}
    if(currentTime<=timeValues[0]){currentTime=timeValues[0];direction=1;}
    document.getElementById("timeSlider").value=currentTime;
    updateEdges(currentTime);
  }

  group.rotation.y+=0.002;

  Object.values(labels).forEach(l=>{
    const d=camera.position.distanceTo(l.position);
    const s=THREE.MathUtils.clamp(6/d,0.6,1.4);
    l.scale.set(s,s,s);
  });

  renderer.render(scene,camera);
}
</script>

</body>
</html>
