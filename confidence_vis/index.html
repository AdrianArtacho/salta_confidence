<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Time-Resolved Modality Agreement (3D)</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    color: #eee;
    font-family: sans-serif;
  }
  #ui {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
  }
  #timeLabel {
    text-align: center;
    margin-bottom: 6px;
    font-size: 14px;
  }
  input[type=range] {
    width: 100%;
  }
</style>
</head>

<body>

<div id="ui">
  <div id="timeLabel">t = 0.00</div>
  <input id="timeSlider" type="range" min="0" max="1" step="0.001">
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
/* ============================================================
   Scene & Camera
============================================================ */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  100
);
camera.position.set(0, 0, 7);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ============================================================
   Globals
============================================================ */

let rows = [], timeValues = [], pairKeys = [], modalities = [];

const group = new THREE.Group();
scene.add(group);

const nodes = {};
const edges = {};
const originalPositions = {};

let focused = null;

const SPHERE_RADIUS = 2.6;
const FOCUS_DEPTH = 3.0;

/* ============================================================
   Load CSV
============================================================ */

fetch("modality_agreement_timeseries.csv")
  .then(r => r.text())
  .then(text => {
    const lines = text.trim().split("\n");
    const headers = lines[0].split(",");
    rows = lines.slice(1).map(l => {
      const p = l.split(",");
      const o = {};
      headers.forEach((h, i) => o[h] = parseFloat(p[i]));
      return o;
    });
    timeValues = rows.map(r => r.time);
    pairKeys = headers.filter(h => h !== "time");
    modalities = [...new Set(pairKeys.flatMap(k => k.split("__")))];
    init();
  });

/* ============================================================
   Init
============================================================ */

function init() {

  /* ---------- Nodes: spherical (Fibonacci) distribution ---------- */

  modalities.forEach((name, i) => {
    const n = modalities.length;

    // Fibonacci / golden-angle sphere
    const phi = Math.acos(1 - 2 * (i + 0.5) / n);
    const theta = Math.PI * (1 + Math.sqrt(5)) * i;

    const x = SPHERE_RADIUS * Math.sin(phi) * Math.cos(theta);
    const y = SPHERE_RADIUS * Math.sin(phi) * Math.sin(theta);
    const z = SPHERE_RADIUS * Math.cos(phi);

    const pos = new THREE.Vector3(x, y, z);

    const mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.22, 20, 20),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );

    mesh.position.copy(pos);
    group.add(mesh);

    nodes[name] = mesh;
    originalPositions[name] = pos.clone();
  });

  /* ---------- Edges ---------- */

  pairKeys.forEach(k => {
    const [a, b] = k.split("__");

    const geom = new THREE.BufferGeometry().setFromPoints([
      nodes[a].position,
      nodes[b].position
    ]);

    const mat = new THREE.LineBasicMaterial({
      color: 0x66ccff,
      transparent: true,
      opacity: 0.15
    });

    const line = new THREE.Line(geom, mat);
    group.add(line);
    edges[k] = line;
  });

  setupUI();
  setupPicking();
  updateEdges(timeValues[0]);
  animate();
}

/* ============================================================
   Interaction (Picking)
============================================================ */

function setupPicking() {
  const ray = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  window.addEventListener("click", e => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(Object.values(nodes));
    if (!hits.length) return;

    const clicked = Object.keys(nodes)
      .find(k => nodes[k] === hits[0].object);

    toggleFocus(clicked);
  });
}

/* ============================================================
   Focus logic (TRUE 3D, group-based)
============================================================ */

function toggleFocus(name) {
  if (focused === name) {
    resetView();
    focused = null;
  } else {
    focusOn(name);
    focused = name;
  }
}

function focusOn(name) {

  const target = originalPositions[name].clone().normalize();

  // rotate group so target points toward camera
  const forward = new THREE.Vector3(0, 0, 1);
  const q = new THREE.Quaternion().setFromUnitVectors(target, forward);
  group.quaternion.copy(q);

  // move whole structure backward so focused node is closer
  group.position.set(0, 0, -FOCUS_DEPTH);

  updateEdgeGeometry();
}

function resetView() {
  group.quaternion.identity();
  group.position.set(0, 0, 0);
  updateEdgeGeometry();
}

/* ============================================================
   Time-dependent edge updates
============================================================ */

function updateEdges(t) {
  let idx = 0, best = Infinity;

  for (let i = 0; i < timeValues.length; i++) {
    const d = Math.abs(timeValues[i] - t);
    if (d < best) { best = d; idx = i; }
  }

  document.getElementById("timeLabel").textContent =
    `t = ${rows[idx].time.toFixed(2)}`;

  pairKeys.forEach(k => {
    const v = rows[idx][k];
    const e = edges[k];
    if (!isFinite(v)) { e.visible = false; return; }
    e.visible = true;
    e.material.opacity = 0.1 + 0.8 * v;
  });
}

function updateEdgeGeometry() {
  pairKeys.forEach(k => {
    const [a, b] = k.split("__");
    edges[k].geometry.setFromPoints([
      nodes[a].position,
      nodes[b].position
    ]);
    edges[k].geometry.attributes.position.needsUpdate = true;
  });
}

/* ============================================================
   UI & render loop
============================================================ */

function setupUI() {
  const s = document.getElementById("timeSlider");
  s.min = timeValues[0];
  s.max = timeValues[timeValues.length - 1];
  s.step = (s.max - s.min) / 1000;
  s.addEventListener("input", () => updateEdges(parseFloat(s.value)));
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>

</body>
</html>
